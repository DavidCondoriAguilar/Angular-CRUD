{"version":3,"sources":["../../src/app/order-pipe/ngx-order.pipe.ts","../../src/app/order-pipe/ngx-order.module.ts"],"names":["OrderPipe","isString","value","String","caseInsensitiveSort","a","b","localeCompare","defaultCompare","Date","getTime","parseExpression","expression","replace","split","getValue","object","i","n","length","k","setValue","prototype","transform","reverse","isCaseInsensitive","comparator","Array","isArray","this","multiExpressionTransform","slice","sortArray","transformObject","Object","assign","array","compareFn","isDeepLink","indexOf","sortedArray","sort","parsedExpression","lastPredicate","pop","oldValue","push","expressions","_this","reduce","result","Pipe","args","name","pure","NgModule","declarations","exports","providers"],"mappings":"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","sourcesContent":["import { Pipe, PipeTransform } from \"@angular/core\";\n\n@Pipe({\n  name: \"orderBy\",\n  pure: false,\n})\nexport class OrderPipe implements PipeTransform {\n  /**\n   * Check if a value is a string\n   *\n   * @param value\n   */\n  static isString(value: any): boolean {\n    return typeof value === \"string\" || value instanceof String;\n  }\n\n  /**\n   * Sorts values ignoring the case\n   *\n   * @param a\n   * @param b\n   */\n  static caseInsensitiveSort(a: any, b: any) {\n    if (OrderPipe.isString(a) && OrderPipe.isString(b)) {\n      return a.localeCompare(b);\n    }\n    return OrderPipe.defaultCompare(a, b);\n  }\n\n  /**\n   * Default compare method\n   *\n   * @param a\n   * @param b\n   */\n  static defaultCompare(a: any, b: any) {\n    if (a && a instanceof Date) {\n      a = a.getTime();\n    }\n    if (b && b instanceof Date) {\n      b = b.getTime();\n    }\n\n    if (a === b) {\n      return 0;\n    }\n    if (a == null) {\n      return 1;\n    }\n    if (b == null) {\n      return -1;\n    }\n    return a > b ? 1 : -1;\n  }\n\n  /**\n   * Parse expression, split into items\n   * @param expression\n   * @returns {string[]}\n   */\n  static parseExpression(expression: string): string[] {\n    expression = expression.replace(/\\[(\\w+)\\]/g, \".$1\");\n    expression = expression.replace(/^\\./, \"\");\n    return expression.split(\".\");\n  }\n\n  /**\n   * Get value by expression\n   *\n   * @param object\n   * @param expression\n   * @returns {any}\n   */\n  static getValue(object: any, expression: string[]): any {\n    for (let i = 0, n = expression.length; i < n; ++i) {\n      if (!object) {\n        return;\n      }\n      const k = expression[i];\n      if (!(k in object)) {\n        return;\n      }\n      if (typeof object[k] === \"function\") {\n        object = object[k]();\n      } else {\n        object = object[k];\n      }\n    }\n\n    return object;\n  }\n\n  /**\n   * Set value by expression\n   *\n   * @param object\n   * @param value\n   * @param expression\n   */\n  static setValue(object: any, value: any, expression: string[]) {\n    let i;\n    for (i = 0; i < expression.length - 1; i++) {\n      object = object[expression[i]];\n    }\n\n    object[expression[i]] = value;\n  }\n\n  transform(\n    value: any | any[],\n    expression?: any,\n    reverse?: boolean,\n    isCaseInsensitive: boolean = false,\n    comparator?: Function\n  ): any {\n    if (!value) {\n      return value;\n    }\n\n    if (Array.isArray(expression)) {\n      return this.multiExpressionTransform(\n        value,\n        expression.slice(),\n        reverse,\n        isCaseInsensitive,\n        comparator\n      );\n    }\n\n    if (Array.isArray(value)) {\n      return this.sortArray(\n        value.slice(),\n        expression,\n        reverse,\n        isCaseInsensitive,\n        comparator\n      );\n    }\n\n    if (typeof value === \"object\") {\n      return this.transformObject(\n        Object.assign({}, value),\n        expression,\n        reverse,\n        isCaseInsensitive,\n        comparator\n      );\n    }\n\n    return value;\n  }\n\n  /**\n   * Sort array, returns sorted array\n   *\n   * @param array\n   * @param expression\n   * @param reverse\n   * @param isCaseInsensitive\n   * @param comparator\n   * @returns {Type[]}\n   */\n  private sortArray<Type>(\n    array: Type[],\n    expression?: any,\n    reverse?: boolean,\n    isCaseInsensitive?: boolean,\n    comparator?: Function\n  ): Type[] {\n    const isDeepLink = expression && expression.indexOf(\".\") !== -1;\n\n    if (isDeepLink) {\n      expression = OrderPipe.parseExpression(expression);\n    }\n\n    let compareFn: Function;\n\n    if (comparator && typeof comparator === \"function\") {\n      compareFn = comparator;\n    } else {\n      compareFn = isCaseInsensitive\n        ? OrderPipe.caseInsensitiveSort\n        : OrderPipe.defaultCompare;\n    }\n\n    const sortedArray: any[] = array.sort((a: any, b: any): number => {\n      if (!expression) {\n        return compareFn(a, b);\n      }\n\n      if (!isDeepLink) {\n        if (a && b) {\n          return compareFn(a[expression], b[expression]);\n        }\n        return compareFn(a, b);\n      }\n\n      return compareFn(\n        OrderPipe.getValue(a, expression),\n        OrderPipe.getValue(b, expression)\n      );\n    });\n\n    if (reverse) {\n      return sortedArray.reverse();\n    }\n\n    return sortedArray;\n  }\n\n  /**\n   * Transform Object\n   *\n   * @param value\n   * @param expression\n   * @param reverse\n   * @param isCaseInsensitive\n   * @param comparator\n   * @returns {any[]}\n   */\n  private transformObject(\n    value: any | any[],\n    expression?: any,\n    reverse?: boolean,\n    isCaseInsensitive?: boolean,\n    comparator?: Function\n  ): any {\n    const parsedExpression = OrderPipe.parseExpression(expression);\n    let lastPredicate = parsedExpression.pop();\n    let oldValue = OrderPipe.getValue(value, parsedExpression);\n\n    if (!Array.isArray(oldValue)) {\n      parsedExpression.push(lastPredicate);\n      lastPredicate = null;\n      oldValue = OrderPipe.getValue(value, parsedExpression);\n    }\n\n    if (!oldValue) {\n      return value;\n    }\n\n    OrderPipe.setValue(\n      value,\n      this.transform(oldValue, lastPredicate, reverse, isCaseInsensitive),\n      parsedExpression\n    );\n    return value;\n  }\n\n  /**\n   * Apply multiple expressions\n   *\n   * @param value\n   * @param {any[]} expressions\n   * @param {boolean} reverse\n   * @param {boolean} isCaseInsensitive\n   * @param {Function} comparator\n   * @returns {any}\n   */\n  private multiExpressionTransform(\n    value: any,\n    expressions: any[],\n    reverse: boolean,\n    isCaseInsensitive: boolean = false,\n    comparator?: Function\n  ): any {\n    return expressions.reverse().reduce((result: any, expression: any) => {\n      return this.transform(\n        result,\n        expression,\n        reverse,\n        isCaseInsensitive,\n        comparator\n      );\n    }, value);\n  }\n}\n","/**\n * Created by vadimdez on 20/01/2017.\n */\nimport { NgModule } from '@angular/core';\nimport { OrderPipe } from './ngx-order.pipe';\n\n@NgModule({\n  declarations: [OrderPipe],\n  exports: [OrderPipe],\n  providers: [OrderPipe]\n})\nexport class OrderModule {}\n"]}